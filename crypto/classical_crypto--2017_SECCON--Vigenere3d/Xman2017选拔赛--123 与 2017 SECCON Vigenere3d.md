## 2017 年 xman 选拔赛——一二三，木头人 
> 我数 123 木头人，再不行动就要被扣分。
23731263111628163518122316391715262121
密码格式 xman{flag}


**解：**
看到一堆数字，首先想一下它是不是十六进制的各式，仔细一看，发现没有出现**0**，也没有出现**a-f**，因此它不是十六进制的形式。然后在纯数字的情况下，一般会考虑Polybius密码，01248密码和键盘密码。然后密文数字的出现情况不符合前两种密码密文的情况，因此会考虑键盘密码。

键盘密码也分为很多种，但是发现密文中1，2，3出现的频率相对较高，而且也有 **“123木头人”**的提示，因此我们猜测其为电脑键盘坐标密码。原理是键盘中的英文字母键中，数字1所对应的列**QAZ**为第一列，数字2所对应的列**WSX**为第二列，以此类推。然后**QWE...**为第一行，**ASD...**为第二行等等。

因此我们把密文的前两位**23**取出，理论上应该是对应的英文字母为**x**，所以判断出是先取列数字，再取行数字。我们继续验证，发现**73**的确对应着**m**这个字母，因此我们按照此方法进行解密,flag字段先拆分为```111 62 81 63 51 81 22 31 63 91 71 52 62 121```，然后解密得到的明文为：``` xman{hintisenough} ```，即hint is enough

---

## 2017 SECCON Vigenere3d
题目
```py
# Vigenere3d.py
import sys
def _l(idx, s):
    return s[idx:] + s[:idx]
def main(p, k1, k2):
    s = "ABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789abcdefghijklmnopqrstuvwxyz_{}"
    t = [[_l((i+j) % len(s), s) for j in range(len(s))] for i in range(len(s))]
    i1 = 0
    i2 = 0
    c = ""
    for a in p:
        c += t[s.find(a)][s.find(k1[i1])][s.find(k2[i2])]
        i1 = (i1 + 1) % len(k1)
        i2 = (i2 + 1) % len(k2)
    return c
print main(sys.argv[1], sys.argv[2], sys.argv[2][::-1])

$ python Vigenere3d.py SECCON{**************************} **************
POR4dnyTLHBfwbxAAZhe}}ocZR3Cxcftw9
```

**解：**

首先我们观察得到明文的长度和密文的长度是相等的，然后密钥的长度是14。

然后文章题目中提示了Vigenere3d，相当于就是维吉尼亚密码的3d版，但是一开始我向着原始的维吉尼亚密码进行分析，然后发现没有办法入手，因为密钥的长度是14，但是明密文对只给出了7个，无法顺利进行解密。因此我们还需要更细致地对方案进行分析。

然后发现实质上t是一个三维的矩阵，通过构造t的定义发现$t[i][j][k] = t[j][i][k]$，然后固定$t[i]$，第j列每增加一列，s数组就向左循环移位一位，因此如果移位前要取第$k$位字符，那么想要获得相同的元素，那么s移位后就要取第$k-1$位字符。因此可知只要$j_1 + k_1 = j_2 + k_2$，那么$t[i][j_1][k_1] = t[i][j_2][k_2]$。因此当$i+1 + j_1 + k_1 = i_2 + j_2 + k_2$，则有$t[i_1][j_1][k_1] = t[i_2][j_2][k_2]$。

接下来发现第i行表示的同样是s向左循环移位i位，因此本质上加密就是s循环移动i+j+k位，然后取s的第一位数。

又因为k1和k2两个密钥刚好长度相同，顺序相反，因此对第一个明文加密的密钥就相当于密钥k的第一位和最后一位作为t[i][j][k]中的j和k，因此实质上第1位密钥和第14位密钥作用相同，第2位密钥和第13位密钥作用相同。然后看明文和密文刚好可以恢复出7个运算时的密钥即j+k，因此另外的7个可以通过上面的性质对称过去，这样运算时的密钥就恢复出来了。然后通过这个密钥就可以通过密文恢复出明文。

##### 实际求解
上面讲的是密码的分析过程，密钥恢复的过程如下：
因为明文就相当于表示t[i]，即s移动了明文字母这么多位，明文字母现在在第一位，然后通过密钥循环左移了j+k位，得到密文。因此恢复j+k就只需要密文的位置减去明文的位置。通过已知的明密文对手动计算密钥：
[-3, 10, 15, 28, 25, 36, -3]
每个数字num表示密文在明文的右边num位，然后通过对称恢复出14个运算时的密钥
[-3, 10, 15, 28, 25, 36, -3, -3, 36, 25, 28, 15, 10, -3]
因此通过下面的代码可以根据密文恢复出明文：
```py
s = "ABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789abcdefghijklmnopqrstuvwxyz_{}"
ukey = [-3, 10, 15, 28, 25, 36, -3, -3, 36, 25, 28, 15, 10, -3]
cip = 'POR4dnyTLHBfwbxAAZhe}}ocZR3Cxcftw9'
l = len(s)
expukey = []
for i in range(len(cip)//len(ukey)):
    expukey += ukey
expukey += ukey[:(len(cip) % len(ukey))]
plaintext = [s[(s.find(cip[i]) - expukey[i] + l) % l] for i in range(len(cip))]
print("".join(plaintext))
```
运行结果：
```
SECCON{Welc0me_to_SECCON_CTF_2017}
```


***有一说一，感觉Crypto的题目非常的考察观察的能力，实质上这道题也是凭借观察然后进行分析。这道题没有看题解，全都是自己想的。更清晰明了的解法ctf-wiki上面有***