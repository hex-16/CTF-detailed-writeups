## 2020_纵横杯--common
## 比赛日期：2020年12月26日

## 题目
有1个python文件``task2.py``和1个数据文件``task2.txt``。
```python
from Crypto.Util.number import *

e1 =  28720970875923431651096339432854172528258265954461865674640550905460254396153781189674547341687577425387833579798322688436040388359600753225864838008717449960738481507237546818409576080342018413998438508242156786918906491731633276138883100372823397583184685654971806498370497526719232024164841910708290088581
e2 =  131021266002802786854388653080729140273443902141665778170604465113620346076511262124829371838724811039714548987535108721308165699613894661841484523537507024099679248417817366537529114819815251239300463529072042548335699747397368129995809673969216724195536938971493436488732311727298655252602350061303755611563
N =  159077408219654697980513139040067154659570696914750036579069691821723381989448459903137588324720148582015228465959976312274055844998506120677137485805781117564072817251103154968492955749973403646311198170703330345340987100788144707482536112028286039187104750378366564167383729662815980782817121382587188922253
flag = b"flag{xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx}"
f1 = bytes_to_long(flag[:21])
f2 = bytes_to_long(flag[21:])
c1 = pow(f1, e1, N)
c2 = pow(f2, e2, N)

print("e1 = ", e1)
print("e2 = ", e2)
print("N = ", N)
print("c1 = ", c1)
print("c2 = ", c2)
```

## 解题

题目非常的直白明了，就是一个模数N下两个公钥指数$e_1,e_2$对flag进行加密。同样是做题的时候没有经验。现在看来题目非常的直白。因为公钥指数$e_1,e_2$都比较的大，因此无法使用小公钥指数的情况。而且题目又给出了两个公钥指数，这很容易想到使用**小解密指数攻击**中的**Extending Wiener's Attack**。虽然题目没有直接说明解密指数比较的小，不过看到两个公钥指数就一般都会先尝试使用这个攻击方法。

* 直接上代码，代码在``task2_solution.py``文件中

```python
# task2_solution.py
# coding=utf-8
from Crypto.Util.number import *
from gmpy2 import invert


def extendedWienerAttack(alpha, e1, e2, N):
    ### 这里的alpha参数需要尽量的精确，就是说alpha需要很接近私钥指数的长度与N的长度的比值
    M1 = N ** 0.5
    M2 = N ** (alpha + 1)
    D = diagonal_matrix(ZZ, [N, M1, M2, 1])
    M = matrix(ZZ, [[1, -N, 0, N ** 2], [0, e1, -e1, -e1 * N], [0, 0, e2, -e2 * N], [0, 0, 0, e1 * e2]]) * D
    L = M.LLL()
    t = vector(ZZ, L[0])
    x = t * M ** (-1)
    phi = int(x[1] / x[0] * e1)
    return phi


e1 = 28720970875923431651096339432854172528258265954461865674640550905460254396153781189674547341687577425387833579798322688436040388359600753225864838008717449960738481507237546818409576080342018413998438508242156786918906491731633276138883100372823397583184685654971806498370497526719232024164841910708290088581
e2 = 131021266002802786854388653080729140273443902141665778170604465113620346076511262124829371838724811039714548987535108721308165699613894661841484523537507024099679248417817366537529114819815251239300463529072042548335699747397368129995809673969216724195536938971493436488732311727298655252602350061303755611563
N = 159077408219654697980513139040067154659570696914750036579069691821723381989448459903137588324720148582015228465959976312274055844998506120677137485805781117564072817251103154968492955749973403646311198170703330345340987100788144707482536112028286039187104750378366564167383729662815980782817121382587188922253
# a = 0.356  # 5/14-epsilon

phi = extendedWienerAttack(a,e1,e2,N)
d1 = invert(e1, phi)
d2 = invert(e2, phi)
print(size(d1), size(d2))
# 305 305

c1 =  159027516047788038136936101067827826261145305226956010164272432122189269820030793339647943080866758580931517274158104252668222829736484434778373837724491006882862127521025778174550298445011437239414348800563026625846724870527173904900946879799350044899001628956110538387726684347085345436119316245641264449001
c2 =  147688297023004004368549441618136717414204996718939799841118824148125755141211308809170475348273150200292077745921324837789517407646164473427583860667033116651591422703679649606236800024879211937766189832672998961757484607452027182780950693143461083628081662563035109815943093665600839380814432803858191065093

m1 = pow(c1, d1, N)
m2 = pow(c2, d2, N)

m1 = long_to_bytes(m1)
m2 = long_to_bytes(m2)
print(m1+m2)
```

在``Sagemath9.2``中运行的结果:
```
305 305
b'flag{ef30c9f9-f9b7-4b6c-9947-dd2db372de4f}'
```
从而flag就得到了。