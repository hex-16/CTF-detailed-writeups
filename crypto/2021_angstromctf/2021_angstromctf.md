https://2021.angstromctf.com/

# Angstromctf

其中crypto有12道题，我做出来10道，第11道看别人的writeup做出来的，最后一道只有5个人做出来的题目就看别人的writeup也看不懂emmmmmmmmm

---

## Relatively Simple Algorithm
RSA给出了p和q，e，这道题白给。
actf{old_but_still_good_well_at_least_until_quantum_computing}

## Exclusive Cipher
使用了XOR Cipher
```
ae27eb3a148c3cf031079921ea3315cd27eb7d02882bf724169921eb3a469920e07d0b883bf63c018869a5090e8868e331078a68ec2e468c2bf13b1d9a20ea0208882de12e398c2df60211852deb021f823dda35079b2dda25099f35ab7d218227e17d0a982bee7d098368f13503cd27f135039f68e62f1f9d3cea7c

The key is 5 bytes long and the flag is somewhere in the message.
```
https://www.dcode.fr/xor-cipher
选择密钥长度然后解密，即可得到结果
actf{who_needs_aes_when_you_have_xor}

## Keysar v2
替换密码
```
quutcvbmy ft qii amtkm iqkd tx qjbqfbtm, fzwcw bd mt kqo q sww dztgiv sw qsiw ft xio. bfd kbmyd qcw ftt drqii ft ywf bfd xqf ibffiw stvo txx fzw yctgmv. fzw sww, tx utgcdw, xibwd qmokqo swuqgdw swwd vtm'f uqcw kzqf zgrqmd fzbma bd brhtddbsiw. owiitk, siqua. owiitk, siqua. owiitk, siqua. owiitk, siqua. ttz, siqua qmv owiitk! iwf'd dzqaw bf gh q ibffiw. sqcco! scwqaxqdf bd cwqvo! utrbmy! zqmy tm q dwutmv. zwiit? sqcco? qvqr? uqm otg swibwjw fzbd bd zqhhwmbmy? b uqm'f. b'ii hbua otg gh. ittabmy dzqch. gdw fzw dfqbcd. otgc xqfzwc hqbv yttv rtmwo xtc fztdw. dtcco. b'r wnubfwv. zwcw'd fzw ycqvgqfw. kw'cw jwco hctgv tx otg, dtm. q hwcxwuf cwhtcf uqcv, qii s'd. jwco hctgv. rq! b ytf q fzbmy ytbmy zwcw. otg ytf ibmf tm otgc xgpp. tk! fzqf'd rw! kqjw ft gd! kw'ii sw bm ctk 118,000. sow! sqcco, b ftiv otg, dfth xiobmy bm fzw ztgdw! zwo, qvqr. zwo, sqcco. bd fzqf xgpp ywi? q ibffiw. dhwubqi vqo, ycqvgqfbtm. mwjwc fztgyzf b'v rqaw bf. fzcww vqod ycqvw duztti, fzcww vqod zbyz duztti. fztdw kwcw qkakqcv. fzcww vqod utiiwyw. b'r yiqv b ftta q vqo qmv zbfuzzbawv qctgmv fzw zbjw. otg vbv utrw squa vbxxwcwmf. zb, sqcco. qcfbw, yctkbmy q rgdfquzw? ittad yttv. zwqc qstgf xcqmabw? owqz. otg ytbmy ft fzw xgmwcqi? mt, b'r mtf ytbmy. wjwcostvo amtkd, dfbmy dtrwtmw, otg vbw. vtm'f kqdfw bf tm q degbccwi. dguz q ztfzwqv. b ygwdd zw utgiv zqjw lgdf ytffwm tgf tx fzw kqo. b itjw fzbd bmutchtcqfbmy qm qrgdwrwmf hqca bmft tgc vqo. fzqf'd kzo kw vtm'f mwwv jquqfbtmd. sto, egbfw q sbf tx htrh... gmvwc fzw ubcugrdfqmuwd. kwii, qvqr, ftvqo kw qcw rwm. kw qcw! sww-rwm. qrwm! zqiiwiglqz! dfgvwmfd, xqugifo, vbdfbmygbdzwv swwd, hiwqdw kwiutrw vwqm sgppkwii. kwiutrw, mwk zbjw ubfo ycqvgqfbmy uiqdd tx... ...9:15. fzqf utmuigvwd tgc uwcwrtmbwd. qmv swybmd otgc uqcwwc qf ztmwn bmvgdfcbwd! kbii kw hbua tgclts ftvqo? b zwqcv bf'd lgdf tcbwmfqfbtm. zwqvd gh! zwcw kw yt. awwh otgc zqmvd qmv qmfwmmqd bmdbvw fzw fcqr qf qii fbrwd. ktmvwc kzqf bf'ii sw ibaw? q ibffiw duqco. kwiutrw ft ztmwn, q vbjbdbtm tx ztmwdut qmv q hqcf tx fzw zwnqytm yctgh. fzbd bd bf! ktk. ktk. kw amtk fzqf otg, qd q sww, zqjw ktcawv otgc kztiw ibxw ft ywf ft fzw htbmf kzwcw otg uqm ktca xtc otgc kztiw ibxw. ztmwo swybmd kzwm tgc jqibqmf htiiwm ltuad scbmy fzw mwufqc ft fzw zbjw. tgc fth-dwucwf xtcrgiq bd qgftrqfbuqiio utitc-utccwufwv, duwmf-qvlgdfwv qmv sgssiw-utmftgcwv bmft fzbd dttfzbmy dkwwf docgh kbfz bfd vbdfbmufbjw ytivwm yitk otg amtk qd... ztmwo! fzqf ybci kqd ztf. dzw'd ro utgdbm! dzw bd? owd, kw'cw qii utgdbmd. cbyzf. otg'cw cbyzf. qf ztmwn, kw utmdfqmfio dfcbjw ft brhctjw wjwco qdhwuf tx sww wnbdfwmuw. fzwdw swwd qcw dfcwdd-fwdfbmy q mwk zwirwf fwuzmtityo. kzqf vt otg fzbma zw rqawd? mtf wmtgyz. zwcw kw zqjw tgc iqfwdf qvjqmuwrwmf, fzw acwirqm. qufx{awowvuqwdqcrtcwibawdgsdfbfgfbtm}
```
虽然文章给了源代码，但是可以直接使用http://quipqiup.com/网站进行破解

actf{keyedcaesarmorelikesubstitution}

## Sosig
RSA 
```
n: 14750066592102758338439084633102741562223591219203189630943672052966621000303456154519803347515025343887382895947775102026034724963378796748540962761394976640342952864739817208825060998189863895968377311649727387838842768794907298646858817890355227417112558852941256395099287929105321231423843497683829478037738006465714535962975416749856785131866597896785844920331956408044840947794833607105618537636218805733376160227327430999385381100775206216452873601027657796973537738599486407175485512639216962928342599015083119118427698674651617214613899357676204734972902992520821894997178904380464872430366181367264392613853
e: 1565336867050084418175648255951787385210447426053509940604773714920538186626599544205650930290507488101084406133534952824870574206657001772499200054242869433576997083771681292767883558741035048709147361410374583497093789053796608379349251534173712598809610768827399960892633213891294284028207199214376738821461246246104062752066758753923394299202917181866781416802075330591787701014530384229203479804290513752235720665571406786263275104965317187989010499908261009845580404540057576978451123220079829779640248363439352875353251089877469182322877181082071530177910308044934497618710160920546552403519187122388217521799
c: 13067887214770834859882729083096183414253591114054566867778732927981528109240197732278980637604409077279483576044261261729124748363294247239690562657430782584224122004420301931314936928578830644763492538873493641682521021685732927424356100927290745782276353158739656810783035098550906086848009045459212837777421406519491289258493280923664889713969077391608901130021239064013366080972266795084345524051559582852664261180284051680377362774381414766499086654799238570091955607718664190238379695293781279636807925927079984771290764386461437633167913864077783899895902667170959671987557815445816604741675326291681074212227
```
直接使用boneh and durfee 算法
actf{d0ggy!!!111!1}

## Home Rolled Crypto
```python
#!/usr/bin/python
import binascii
from random import choice

class Cipher:
    BLOCK_SIZE = 16
    ROUNDS = 3
    def __init__(self, key):
        assert(len(key) == self.BLOCK_SIZE*self.ROUNDS)
        self.key = key

    def __block_encrypt(self, block):
        enc = int.from_bytes(block, "big")
        for i in range(self.ROUNDS):
            k = int.from_bytes(self.key[i*self.BLOCK_SIZE:(i+1)*self.BLOCK_SIZE], "big")
            enc &= k
            enc ^= k
        return hex(enc)[2:].rjust(self.BLOCK_SIZE*2, "0")


    def __pad(self, msg):
        if len(msg) % self.BLOCK_SIZE != 0:
            return msg + (bytes([0]) * (self.BLOCK_SIZE - (len(msg) % self.BLOCK_SIZE)))
        else:
            return msg
    
    def encrypt(self, msg):
        m = self.__pad(msg)
        e = ""
        for i in range(0, len(m), self.BLOCK_SIZE):
            e += self.__block_encrypt(m[i:i+self.BLOCK_SIZE])
        return e.encode()

key = binascii.unhexlify("".join([choice(list("abcdef0123456789")) for a in range(Cipher.BLOCK_SIZE*Cipher.ROUNDS*2)]))

with open("flag", "rb") as f:
    flag = f.read()

cipher = Cipher(key)


while True:
    a = input("Would you like to encrypt [1], or try encrypting [2]? ")
    if a == "1":

        p = input("What would you like to encrypt: ")
        try:
            print(cipher.encrypt(binascii.unhexlify(p)).decode())
        except:
            print("Invalid input. ")
    elif a == "2":
        for i in range(10):
            p = "".join([choice(list("abcdef0123456789")) for a in range(64)])
            print("Encrypt this:", p)
            e = cipher.encrypt(binascii.unhexlify(p)).decode()
            c = input()
            if e != c:
                print("L")
                exit()
        print("W")
        print(flag.decode())            

    elif a.lower() == "quit":
        print("Bye")
        exit()
    else:
        print("Invalid input. ")
```

块加密

这个加密不可逆，只是在修改数据，题目的目的是让我们复现这个修改数据的过程。修改过程只有与和异或运算，而且key是不变的。只需要与运算为0的位数是不变的，与运算全为1的位数与1异或即可。

```python
from socket import *

host = 'crypto.2021.chall.actf.co'
# host = '127.0.0.1'
port = 21602
bufsize = 1024
addr = (host, port)
client = socket(AF_INET, SOCK_STREAM)
client.connect(addr)

msg = client.recv(bufsize)
print(msg)
client.send(b'1\n')
msg = client.recv(bufsize)
print(msg)
client.send(b'ffffffffffffffffffffffffffffffff\n')
msg = client.recv(bufsize)
print(msg)
fix = msg[:msg.find(b'\n')]
fix = int(fix, 16)
print(hex(fix))

# msg = client.recv(bufsize)
# print(msg)
client.send(b'1\n')
msg = client.recv(bufsize)
print(msg)
client.send(b'00000000000000000000000000000000\n')
msg = client.recv(bufsize)
tmp1 = msg[:msg.find(b'\n')]
print(msg)
chg = int(tmp1, 16) ^ fix
print(hex(chg))

BLOCK_SIZE = 16
ROUNDS = 3


def pad(m):
    if len(m) % BLOCK_SIZE != 0:
        return m + (bytes([0]) * (BLOCK_SIZE - (len(m) % BLOCK_SIZE)))
        # return m + ''.join([chr(0) for i in range((BLOCK_SIZE - (len(m) % BLOCK_SIZE)))])
    else:
        return m


def encypt(block):
    # print 'block:', block
    enc = int(block, 16)
    # enc = int.from_bytes(block, 'big')
    # enc = enc & chg ^ chg
    enc = fix ^ (enc & chg ^ chg)
    # print hex(enc)
    return hex(enc)[2:].rjust(BLOCK_SIZE * 2, "0")
    # return hex(enc)[2:]

# msg = client.recv(bufsize)
# print(msg)
client.send(b'2\n')
for _ in range(10):
    msg = client.recv(bufsize)
    print(msg)
    EnMsg = msg[msg.find(b':')+2:-1]
    # EnMsg = binascii.unhexlify(msg[msg.find(b':')+2:-1])
    # print(msg[msg.find(b':')+2:-1])
    # EnMsg = pad(EnMsg)
    # print(len(EnMsg))
    e = ''
    for i in range(0, len(EnMsg), BLOCK_SIZE*2):
        e += encypt(EnMsg[i:i+BLOCK_SIZE*2])
    e = e.encode()
    e = e.decode()
    print(e.encode())
    client.send(e.encode()+b'\n')
    # time.sleep(0.5)


msg = client.recv(bufsize)
print(msg)

```

``actf{no_bit_shuffling_is_trivial}``

## Follow the Currents
```python
import os
import zlib
def keystream():
	key = os.urandom(2)
	index = 0
	while 1:
		index+=1
		if index >= len(key):
			key += zlib.crc32(key).to_bytes(4,'big')
		yield key[index]
ciphertext = []
with open("plain","rb") as f:
	plain = f.read()
	assert b"actf{" in plain
	k = keystream()
	for i in plain:
		ciphertext.append(i ^ next(k))
with open("enc","wb") as g:
	g.write(bytes(ciphertext))
```

流密码
密码文件在``enc``文件中
一个可复现的流密码，而且种子的长度只有65535，因此直接暴力模拟种子，然后运算找到结果。

```python
# python3

import os
import zlib
import binascii


def keystream(kk):
    # key = os.urandom(2)
    # khi = hex(kk >> 8)[2:].rjust()
    # klo = kk & 0xff
    # key = (hex(khi)[2:]+hex(klo)[2:]).decode('hex')
    key = binascii.unhexlify(hex(kk)[2:].rjust(4, '0'))
    index = 0
    while 1:
        index += 1
        if index >= len(key):
            key += zlib.crc32(key).to_bytes(4, 'big')
        yield key[index]


with open("enc", 'rb') as f:
    ciphertext = f.read()

judge = False
plaintext = 0
for j in range(1, 65536):
    # print(j)
    cipher = []
    k = keystream(j)
    for i in ciphertext:
        # cipher.append(hex(ord(i) ^ ord(next(k)))[2:].decode('hex'))
        cipher.append(i ^ next(k))
    cipher = b''.join([binascii.unhexlify(hex(c)[2:].rjust(2, "0")) for c in cipher])
    if b'actf{' in cipher:
        plaintext = cipher
        judge = True
print(plaintext)

```

``actf{low_entropy_keystream}``

## I'm so Random
```python
import time
import random
import os

class Generator():
    DIGITS = 8
    def __init__(self, seed):
        self.seed = seed
        assert(len(str(self.seed)) == self.DIGITS)

    def getNum(self):
        self.seed = int(str(self.seed**2).rjust(self.DIGITS*2, "0")[self.DIGITS//2:self.DIGITS + self.DIGITS//2])
        return self.seed


r1 = Generator(random.randint(10000000, 99999999))
r2 = Generator(random.randint(10000000, 99999999))


query_counter = 0
while True:
    query = input("Would you like to get a random output [r], or guess the next random number [g]? ")
    if query.lower() not in ["r", "g"]:
        print("Invalid input.")
        break
    else:
        if query.lower() == "r" and query_counter < 3:
            print(r1.getNum() * r2.getNum())
            query_counter += 1;
        elif query_counter >= 3 and query.lower() == "r":
            print("You don't get more random numbers!")
        else:
            for i in range(2):
                guess = int(input("What is your guess to the next value generated? "))
                if guess != r1.getNum() * r2.getNum():
                    print("Incorrect!")
                    exit()
            with open("flag", "r") as f:
                fleg = f.read()
            print("Congrats! Here's your flag: ")
            print(fleg)
            exit()
```

随机数生成器

这是一个平方移位生成器
设$10000000<=s<=99999999$为种子，则下一个生成随机数的表达式为：$s_{new}=(s^2 // 1000)\ mod\ 100000000$

题目中只给3个随机数，然后猜后续的2个随机数
理论上应该是有正常的解决方法的，但是由于种子的范围过小，先获取3个随机数，然后暴力破解可得。

```python
# python3
class Generator:
    DIGITS = 8

    def __init__(self, seed):
        self.seed = seed
        assert (len(str(self.seed)) == self.DIGITS)

    def getNum(self):
        self.seed = int(
            str(self.seed ** 2).rjust(self.DIGITS * 2, "0")[self.DIGITS // 2:self.DIGITS + self.DIGITS // 2])
        return self.seed


r1 = 241794940771320
r2 = 933136761714201
r3 = 2418528371611984

for i in range(10000000, 99999999):
    if i % 100000==0:
        print(i)
    g1 = Generator(i)
    a1 = g1.getNum()
    if a1 == 0:
        continue
    if r1 % a1 == 0 and 10000000 <= r1 / a1 <= 99999999:
        # print(r1 / a1)
        g2 = Generator(int(r1 / a1))
        a2 = g1.getNum()
        b2 = g2.getNum()
        if r2 == a2 * b2 :
            a3 = g1.getNum()
            b3 = g2.getNum()
            if r3 == a3 * b3:
                print(g1.getNum() * g2.getNum())
                print(g1.getNum() * g2.getNum())
                exit()
        else:
            continue

```

``actf{middle_square_method_more_like_middle_fail_method}``

## Circle of Trust
```python
import random
import secrets
import math
from decimal import Decimal, getcontext
from Crypto.Cipher import AES

BOUND = 2 ** 128
MULT = 10 ** 10

getcontext().prec = 50

def nums(a):
    b = Decimal(random.randint(-a * MULT, a * MULT)) / MULT
    c = (a ** 2 - b ** 2).sqrt()
    if random.randrange(2):
        c *= -1
    return (b, c)


with open("flag", "r") as f:
    flag = f.read().strip().encode("utf8")

diff = len(flag) % 16
if diff:
    flag += b"\x00" * (16 - diff)

keynum = secrets.randbits(128)
ivnum = secrets.randbits(128)

key = int.to_bytes(keynum, 16, "big")
iv = int.to_bytes(ivnum, 16, "big")

x = Decimal(random.randint(1, BOUND * MULT)) / MULT
for _ in range(3):
    (a, b) = nums(x)
    print(f"({keynum + a}, {ivnum + b})")

cipher = AES.new(key, AES.MODE_CBC, iv=iv)
enc = cipher.encrypt(flag)
print(enc.hex())
```

数据
```
(45702021340126875800050711292004769456.2582161398, 310206344424042763368205389299416142157.00357571144)
(55221733168602409780894163074078708423.359152279, 347884965613808962474866448418347671739.70270575362)
(14782966793385517905459300160069667177.5906950984, 340240003941651543345074540559426291101.69490484699)
838371cd89ad72662eea41f79cb481c9bb5d6fa33a6808ce954441a2990261decadf3c62221d4df514841e18c0b47a76
```

一道解非线性方程的题目

使用matlab或者python即可，需要注意的是数据过长，直接输入的话精度会丢失，需要先转化成字符串，然后把字符串再转换位数字精度才不会丢失。

```matlab
syms b1 b2 b3 k x iv;
% syms u v;
digits(70);

eq1 = str2sym('b1+k == 45702021340126875800050711292004769456.2582161398');
eq2 = str2sym('b2+k == 55221733168602409780894163074078708423.359152279');
eq3 = str2sym('b3+k == 14782966793385517905459300160069667177.5906950984');
eq4 = str2sym('-(x^2-b1^2)^0.5 + iv == 310206344424042763368205389299416142157.00357571144');
eq5 = str2sym('(x^2-b2^2)^0.5 + iv == 347884965613808962474866448418347671739.70270575362');
eq6 = str2sym('(x^2-b3^2)^0.5 + iv == 340240003941651543345074540559426291101.69490484699');
eqns = [eq1,eq2,eq3,eq4,eq5,eq6];

% S = solve(eqns,[b1 b2 b3 k x iv])
S = vpasolve(eqns,[b1 b2 b3 k x iv])
disp([S.b1 S.b2 S.b3 S.k S.x S.iv]);
disp([S.k S.iv]);
```

```python
from decimal import Decimal, getcontext
from Crypto.Cipher import AES
import binascii
from fractions import Fraction
from scipy.optimize import fsolve
import secrets


k = 37208231231867697178862544207654698732
iv = 332394261916597077667241952352964236593

cipher = b'838371cd89ad72662eea41f79cb481c9bb5d6fa33a6808ce954441a2990261decadf3c62221d4df514841e18c0b47a76'

for i in range(-20, 20):
    if i%100 == 0:
        print(i)
    key = int.to_bytes(k + i, 16, 'big')
    for j in range(-20, 20):
        ivt = int.to_bytes(iv+j, 16, 'big')
        aes = AES.new(key, AES.MODE_CBC, iv=ivt)
        dec = aes.decrypt(binascii.unhexlify(cipher))
        if b'actf' in dec:
            print(dec)

```

``actf{elliptical_curve_minus_the_curve}``

## Substitution
```python
#!/usr/bin/python

from functools import reduce

with open("flag", "r") as f:
    key = [ord(x) for x in f.read().strip()]


def substitute(value):
    return (reduce(lambda x, y: x*value+y, key))%691


print("Enter a number and it will be returned with our super secret synthetic substitution technique")
while True:
    try:
        value = input("> ")
        if value == 'quit':
            quit()
        value = int(value)
        enc = substitute(value)
        print(">> ", end="")
        print(enc)
    except ValueError:
        print("Invalid input. ")
```

置换密码
明文的线性置换，解线性方程组即可得到flag

```python
from sympy import Matrix
import socket
import sympy


def genMatrix(n):
    A = []
    for j in range(n+1):
        if j == 0:
            A.append([0 for _ in range(i)] + [1])
        else:
            tmp = []
            tmp2 = 1
            for k in range(n+1):
                tmp.append(tmp2)
                tmp2 = tmp2*j % 691
            tmp.reverse()
            A.append(tmp)
    A.reverse()
    return Matrix(A)


host = 'crypto.2021.chall.actf.co'
# host = '127.0.0.1'
port = 21601
bufsize = 1024
addr = (host, port)
client = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
client.connect(addr)

msg = client.recv(bufsize)
print(msg)
B = []
for i in range(300):
    # msg = client.recv(bufsize)  # '> '
    # print(msg)

    client.send(str(i).encode()+b'\n')

    msg = client.recv(bufsize)  # '>> '
    print(msg)
    num = int(msg[3:-3])
    # num = int(msg[3:-1])
    B = [num] + B

    A = genMatrix(i)
    print(i)
    # print(A)
    try:
        A_inv = A.inv_mod(691)
        # print(A_inv)
    except sympy.matrices.common.NonInvertibleMatrixError:
        print('No invert')
        continue
    MB = Matrix(B)

    flag = list(A_inv*MB)
    flag = [_ % 691 for _ in flag]
    if any(_ > 255 for _ in flag):
        continue
    else:
        print('result: ',''.join([chr(j) for j in flag]))

```

```actf{polynomials_20a829322766642530cf69}```

## Oracle of Blair
```python
from Crypto.Cipher import AES
from Crypto.Util.Padding import pad
import os

key = os.urandom(32)
flag = open("flag","rb").read()

while 1:
	try:
		i = bytes.fromhex(input("give input: "))
		if not i:
			break
	except:
		break
	iv = os.urandom(16)
	inp = i.replace(b"{}", flag)
	if len(inp) % 16:
		inp = pad(inp, 16)
	print(
		AES.new(key, AES.MODE_CBC, iv=iv).decrypt(inp).hex()
	)
```

AES

用了CBC模式的解密运算作为加密，信息泄露得非常的厉害。
因为随机向量iv已经没有用了。然后题目中没有泄露AES的密钥，因此需要把AES看成一个黑箱。

题目中已知flag占两个block，padding有7个字符。

1. 输入$flag + padding + flag$在第三个block得到$f2^E(f1)$和第四个block得到$f1^E(f2)$。
2. 输入$32个0 + flag$ 得到$E(f1)$，因此计算得到$f2$。
3. 输入$32个0 + f2_{with padding}$，得到$E(f2)$，与第一步中的进行异或得到$f1$。因此获得了flag。

当flag的块数增加的时候也能用同样的方法恢复。

```python
# python3 
from Crypto.Cipher import AES
from Crypto.Util.Padding import pad
import os
import socket
import binascii

host = 'crypto.2021.chall.actf.co'
# host = '127.0.0.1'
port = 21112
bufsize = 1024
addr = (host, port)
client = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
client.connect(addr)

msg = client.recv(bufsize)
print(msg)
client.send(b'7b7d000000000000007b7d\n')  # 记得要填充
msg = client.recv(bufsize)
print(msg, msg[64:64+32])
f2_ef1 = int(msg[64:64+32], 16)
f1_ef2 = int(msg[96:96+32], 16)

# msg = client.recv(bufsize)
# print(msg)
client.send(b'000000000000000000000000000000007b7d\n')
msg = client.recv(bufsize)
print(msg, msg[64:64+32])
ef1_0 = int(msg[32:32+32], 16)

guess = bytes.fromhex(hex(f2_ef1 ^ ef1_0)[2:].rjust(32, '0'))

guess = guess[:-7]
guess = pad(guess, 16)
print(guess)
# msg = client.recv(bufsize)
# print(msg)
client.send(b'00000000000000000000000000000000' + binascii.hexlify(guess) +b'\n')
msg = client.recv(bufsize)
print(msg, msg[32:32+32])
ef2 = int(msg[32:32+32], 16)

flag = bytes.fromhex(hex(f1_ef2 ^ ef2)[2:].rjust(32, '0'))
print(flag)


```

``actf{cbc_more_like_ecb_c}``

## Thunderbolt
题目给出了一个叫``chall``的elf文件，本质上就是题目中的一个可执行文件，相当于一个流密码。

题解就是输入足够多的输入，比如说``A``，然后密码的末尾会跟着非常多的字母``A``的ASCII码，然后后面跟着一串十六进制字符串，把该字符串转换为字母就能得到flag。

Original writeup (https://github.com/K1nd4SUS/CTF-Writeups/tree/main/%C3%A5ngstromCTF_2021/Thunderbolt).

## Cache Money

并看不懂这道题要干什么。有自己实现的AES，然后还有和web相关攻击。

Reference：

https://mystiz.hk/posts/2021-04-08-angstromctf-2021/

https://gist.github.com/samueltangz/cbba3f529d07396d1a196ebf7693599f#file-angstromctf-2021-cache-money-solve-py