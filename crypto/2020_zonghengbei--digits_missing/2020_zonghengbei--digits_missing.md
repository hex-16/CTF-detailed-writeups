## 2020_纵横杯--digits_missing
## 比赛日期：2020年12月26日

## 题目
有1个python文件``task.py``和1个数据文件``task.txt``。
```py
# task.py
from gmpy2 import *
from Crypto.Util.number import *
from random import getrandbits
import uuid

flag = 'flag{' + str(uuid.uuid4()) + '}'
flag = flag.encode().strip(b'flag{').strip(b'}').split(b'-')
padding = long_to_bytes(getrandbits(512))

m = bytes_to_long(flag[0] + padding + b''.join([_ for _ in flag[1:]]))


def leak(a, b, c):
    e1, e2 = a >> 32, a & 2 ** 32 - 1
    m1, m2 = b >> 256, b & 2 ** 256 - 1 #python train.py --env-name='<env pn
    p, q = getPrime(512), getPrime(512)
    e = getPrime(32)
    n = p * q
    d = invert(e, (p - 1) * (q - 1))
    c1 = pow(b, e, n)
    c2 = pow((m1 + m2), (e1 + e2), n)
    c3 = pow(a, a, n)
    c4 = pow(c, 0x10001, n)

    return p, q, d % (p - 1), d % (q - 1), c1, c2, c3, c4


def enc(m):
    p = getPrime(512)
    q = getPrime(512)
    e = 5
    n = p * q
    c = pow(m, e, n)
    return c, n


l = leak(bytes_to_long(flag[0]), bytes_to_long(padding), bytes_to_long(flag[1] + flag[2]))
c, n = enc(m)
print(l)
print(n)
print(c)
```

## 解题

1. 题目中的m是flag加padding加右面一串文字，然后从leak函数中通过分析可以恢复出a,b和c.

2. 从泄露出的a，b，c组成了m的高位的大半部分，而且此时e很小(只有5)，因此可以使用“已知高比特信息攻击”把所有的m恢复出来。

### leak函数中数据的恢复
1. 由于$p,q$已知，因此$n$与$\phi(n)$可知。首先恢复出$c$。
$$c = c_4^{(0x10001\ mod\ \phi(n))^{-1}}\ mod\ n$$

2. 然后根据中国剩余定理恢复出$b$。
$$\begin{cases}
d\equiv d_p\ mod\ (p-1)\\
d\equiv d_q\ mod\ (q-1)\\
\end{cases}$$因此根据中国剩余定理容易恢复出$d$，注意$p-1$与$q-1$不互素，需要用到模不互素时的求解方法。因此$$b\equiv c_1^d\ mod\ n$$

3. 通过中间相遇攻击恢复出$a$。
因为题目中给出了$$c_2 = (m_1+m_2)^{e_1+e_2}\ mod\ n$$因此有$$c_2 = (m_1+m_2)^{e_1}(m_1+m_2)^{e_2}\ mod\ n$$主要的思想位遍历所有的$e_1$，求出所有$$c_2((m_1+m_2)^{e_1})^{-1}\equiv (m_1+m_2)^{e_2} \ mod\ n$$并把他们存储在以一个列表``LIST``中。然后遍历所有的$e_2$并计算$(m_1+m_2)^{e_2}$看是否在``LIST``中，若存在，判断是否满足$c_3$的等式，若满足，则找到$a$。

恢复a,b,c主要通过``task_solution_abc.py``文件实现。
```python
# task_solution_abc.py
from gmpy2 import *
import itertools

p, q, dmp, dmq, c1, c2, c3, c4 = 12088887485280517146272351590086025512894829636183954778563449580550231370376017554816220328955961172075206459267753929996237621298555579019727394465674063L, 11344223853740693557654410531952195662821090736896673801003676892459775449192551267317101594215180569551903151725246207006028341210716508671503703010092427L, mpz(10032761362528417809390786686983630749882852861617512113543758973557077707894035928506123156110127559375548294496563592927368299484757626525952458340568503L), mpz(4868092267168885038974809401311095920573250902516232858368050006494301884831642892750785770087167286801734022695787726561945151455977178294054408017682577L), 30875403489876653885912547279018806549030905480248397936846247378245217866257457222440730253201998862445121908304324870229231062775227856785108589489716468723769279647110987048414321923856621576438500825110176611429118306067270762875938728994680679031824430158750808640691062408446878763972845493756699928493L, 1042892267355594297120540442368551754479736519333196669066168173894861527888583645029915429895390975939643541002325080677596334842933885095969973479367082602176378286808385571707413736310408401831698246429745043504546544024553352281916164014254561193273162048745382153304092774308783733558427045943861420522L, 13305663883272784424661605146290094046943709696152618284699103777893195792759238135155097653440248019202785016453036037532528697388406129510827220150275169896654638862661849022432212729359296475510022362947180755107281832415074206443768060780664134664521192493999750714278456406689911778065742015535523678936L, 8977734959582960872873572465034715330131594232013324014791049087451625600242275891657172846905069987995860238290582324481257433082768040460319871422977899145905016726462924892566788730774383043248892562204164976344393965963075787162813999301162634347441757624654276169168018637973453997305233254555929739040L

n = p * q
phi_n = (p - 1) * (q - 1)

# recover c
c = pow(c4, invert(0x10001, phi_n), n)

# recover b
g = gcd(p - 1, q - 1)
pp, qq = (p - 1) / g, (q - 1) / g
dp, dq = dmp % pp, dmq % qq
dpq = (dmq - dmp) / g
X = dpq * invert(pp, qq)
d = ((p - 1) * X + dmp) % (pp * qq * g)
b = pow(c1, d, n)

print 'b: ', b
print 'c: ', c

# recover a
m1, m2 = b >> 256, b & 2 ** 256 - 1
alphebet = [48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 97, 98, 99, 100, 101, 102]
LIST = {}
for i, j, k, l in itertools.product(alphebet, repeat=4):
    e1 = (i << 24) + (j << 16) + (k << 8) + l
    LIST[c2 * invert(pow(m1 + m2, e1, n), n) % n] = e1

aa = -1
for i, j, k, l in itertools.product(alphebet, repeat=4):
    e2 = (i << 24) + (j << 16) + (k << 8) + l
    tmp = pow(m1 + m2, e2, n)
    if tmp in LIST:
        e1 = LIST[tmp]
        aa = (e1 << 32) + e2
        if c3 == pow(aa, aa, n):
            a = aa
            break
print 'a: ', aa
```

### 已知高比特信息攻击
理论上这是一个已知的攻击，(个人能力问题，还不太懂它怎么实现，因此这里首先使用现成的库进行实现)。

* 很多writeup都是用的sage，但是我发现magma香得不得了，不知道为什么偏要用sage(个人猜测可能是因为sage是用python写的关系吧)

直接上magma的代码，magma的链接
http://magma.maths.usyd.edu.au/calc/

magma是一个专门用来计算数论的相关的工具，但是线下版本的比较难获得。对于较短或用时不长的代码，magma会更加的方便。网站上有相应的Document不过没有tutorial，所以入门会比较的难(虽然我觉得sage也差不多，不过sage现成函数没有magma多，sage还要自己写逻辑，magma直接调函数就可以了)。
```magma
// magma
// n 为RSA的模数N
n:=113061518849140299143395261356124990808826792416052027569942605340212046492278989825137016502962900412531159933420659047167411702784038372551458395315943385841093879901445609344166629884168858196305952675781919693073036360024648017625981955281393571333991955277042492553914191373132779836213070305257306544583;
R<x> := PolynomialRing(Integers());

// c为加密的结果，就是task.txt中最后的一个数
c := 2339214817367283726506759490423720494013145182897827336760047378449580525910204459167221460175458432884603520847112555781456871445382030469182504935568534402934305271522624944324974244810813120800696935782508204069910404268400581854097937195742955809256445885634138564781876571100279969785138474705072283040;

// 这里的m是flag的高比特信息
m := 316714907915949424038841953926127091332969777737819160399024478601843545979024640380164673746116070832599817185353410273888227806107989548906546323503891802290881197180997706025408261704034731545955681120961277231275367403035295744;
f := (x+m)^5 - c;
hidden:=150;
SmallRoots(f,n, hidden : Bits);
```
最后那个SmallRoots得到的就是“已知高比特信息攻击”的结果。然后把它和$m$拼起来就恢复出了flag。

最后恢复flag通过``task_solution_m.py``文件实现。
```python
# task_solution_m.py
# coding=utf-8
from gmpy2 import *
from Crypto.Util.number import *
p, q, dmp, dmq, c1, c2, c3, c4 = 12088887485280517146272351590086025512894829636183954778563449580550231370376017554816220328955961172075206459267753929996237621298555579019727394465674063L, 11344223853740693557654410531952195662821090736896673801003676892459775449192551267317101594215180569551903151725246207006028341210716508671503703010092427L, mpz(10032761362528417809390786686983630749882852861617512113543758973557077707894035928506123156110127559375548294496563592927368299484757626525952458340568503L), mpz(4868092267168885038974809401311095920573250902516232858368050006494301884831642892750785770087167286801734022695787726561945151455977178294054408017682577L), 30875403489876653885912547279018806549030905480248397936846247378245217866257457222440730253201998862445121908304324870229231062775227856785108589489716468723769279647110987048414321923856621576438500825110176611429118306067270762875938728994680679031824430158750808640691062408446878763972845493756699928493L, 1042892267355594297120540442368551754479736519333196669066168173894861527888583645029915429895390975939643541002325080677596334842933885095969973479367082602176378286808385571707413736310408401831698246429745043504546544024553352281916164014254561193273162048745382153304092774308783733558427045943861420522L, 13305663883272784424661605146290094046943709696152618284699103777893195792759238135155097653440248019202785016453036037532528697388406129510827220150275169896654638862661849022432212729359296475510022362947180755107281832415074206443768060780664134664521192493999750714278456406689911778065742015535523678936L, 8977734959582960872873572465034715330131594232013324014791049087451625600242275891657172846905069987995860238290582324481257433082768040460319871422977899145905016726462924892566788730774383043248892562204164976344393965963075787162813999301162634347441757624654276169168018637973453997305233254555929739040L
# n: 113061518849140299143395261356124990808826792416052027569942605340212046492278989825137016502962900412531159933420659047167411702784038372551458395315943385841093879901445609344166629884168858196305952675781919693073036360024648017625981955281393571333991955277042492553914191373132779836213070305257306544583
# c: 2339214817367283726506759490423720494013145182897827336760047378449580525910204459167221460175458432884603520847112555781456871445382030469182504935568534402934305271522624944324974244810813120800696935782508204069910404268400581854097937195742955809256445885634138564781876571100279969785138474705072283040

# recover all m
a = 3763150252243497520
b = 4010957094992677435331075205271409029631383199926585555284702027910418399772856566863113042978049812537115807584040680786874811477252533745322397747616098
c = 3690755098720429111

m = long_to_bytes(a) + long_to_bytes(b) + long_to_bytes(c)
m = bytes_to_long(m) << 128
print m
# 316714907915949424038841953926127091332969777737819160399024478601843545979024640380164673746116070832599817185353410273888227806107989548906546323503891802290881197180997706025408261704034731545955681120961277231275367403035295744

# 通过magma已知高比特信息攻击得到相应的低比特信息
m += 76270690659566127897814625642773374519
m = long_to_bytes(m)
flag = 'flag{%s-%s-%s-%s-%s}' % (m[:8], m[72: 76], m[76: 80], m[80:84], m[84:])
print(flag)
```

## 复现步骤
1. 运行task.py文件生成flag和对应输出参数。
```
['49e7ee20', '3825', '41d7', '9a3a', '5fec9933c2f7']
(12088887485280517146272351590086025512894829636183954778563449580550231370376017554816220328955961172075206459267753929996237621298555579019727394465674063L, 11344223853740693557654410531952195662821090736896673801003676892459775449192551267317101594215180569551903151725246207006028341210716508671503703010092427L, mpz(10032761362528417809390786686983630749882852861617512113543758973557077707894035928506123156110127559375548294496563592927368299484757626525952458340568503L), mpz(4868092267168885038974809401311095920573250902516232858368050006494301884831642892750785770087167286801734022695787726561945151455977178294054408017682577L), 30875403489876653885912547279018806549030905480248397936846247378245217866257457222440730253201998862445121908304324870229231062775227856785108589489716468723769279647110987048414321923856621576438500825110176611429118306067270762875938728994680679031824430158750808640691062408446878763972845493756699928493L, 1042892267355594297120540442368551754479736519333196669066168173894861527888583645029915429895390975939643541002325080677596334842933885095969973479367082602176378286808385571707413736310408401831698246429745043504546544024553352281916164014254561193273162048745382153304092774308783733558427045943861420522L, 13305663883272784424661605146290094046943709696152618284699103777893195792759238135155097653440248019202785016453036037532528697388406129510827220150275169896654638862661849022432212729359296475510022362947180755107281832415074206443768060780664134664521192493999750714278456406689911778065742015535523678936L, 8977734959582960872873572465034715330131594232013324014791049087451625600242275891657172846905069987995860238290582324481257433082768040460319871422977899145905016726462924892566788730774383043248892562204164976344393965963075787162813999301162634347441757624654276169168018637973453997305233254555929739040L)
113061518849140299143395261356124990808826792416052027569942605340212046492278989825137016502962900412531159933420659047167411702784038372551458395315943385841093879901445609344166629884168858196305952675781919693073036360024648017625981955281393571333991955277042492553914191373132779836213070305257306544583
2339214817367283726506759490423720494013145182897827336760047378449580525910204459167221460175458432884603520847112555781456871445382030469182504935568534402934305271522624944324974244810813120800696935782508204069910404268400581854097937195742955809256445885634138564781876571100279969785138474705072283040
```
2. 把第二行参数复制到``task_solution_abc.py``文件中(记得把括号去掉)，然后恢复出a,b,c。
```
b:  4010957094992677435331075205271409029631383199926585555284702027910418399772856566863113042978049812537115807584040680786874811477252533745322397747616098
c:  3690755098720429111
a:  3763150252243497520
```
3. 把参数复制到``task_solution_m.py``文件中，先把最后四行注释掉然后计算出flag的高比特记$m$。
```
316714907915949424038841953926127091332969777737819160399024478601843545979024640380164673746116070832599817185353410273888227806107989548906546323503891802290881197180997706025408261704034731545955681120961277231275367403035295744
```
4. 把$n,c,m$复制到magma代码的相应位置，然后运行得到结果
```
[ 76270690659566127897814625642773374519 ]
```
5. ``task_solution_m.py``文件去掉第3步的注释，然后把flag的低比特位与高比特位m相加，然后运行程序得到flag。
```
flag{49e7ee20-3825-41d7-9a3a-5fec9933c2f7}
```